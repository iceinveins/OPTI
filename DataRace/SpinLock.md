# <font color="3d8c95">SpinLock自旋锁</font>
## <font color="dc843f">Why SpinLock</font>
#### <font color="dc843f">优点</font>
1. 避免上下文切换开销  
优势：线程在等待锁时不会主动让出 CPU，因此无需经历上下文切换(保存/恢复线程状态、调度等操作)。  
适用场景：当锁的持有时间非常短(例如几行代码、几个指令周期)时，自旋锁的性能通常优于互斥锁(Mutex)，因为忙等待的代价可能低于上下文切换的开销。

2. 多核环境的优化  
优势：在多核 CPU 中，一个线程在某个核心上忙等待时，其他核心上的线程仍可并行执行。如果锁的持有时间极短，忙等待的线程可以快速获取锁，无需等待操作系统的调度。  
适用场景：多核系统中锁竞争不激烈、临界区执行时间极短的场景(例如内核中的某些数据结构保护)。

3. 中断上下文和不可睡眠环境  
强制要求：在中断处理程序(ISR)或内核的某些上下文中(如禁止抢占时)，线程不能进入睡眠状态(例如无法使用互斥锁)。此时必须使用自旋锁，因为它是唯一支持忙等待的同步机制。  
示例：Linux 内核的中断处理代码广泛使用自旋锁。

4. 实时性要求高的场景
优势：自旋锁的等待是“主动”的，线程可以第一时间感知到锁的释放，减少延迟。对于实时系统(如嵌入式系统、高频交易系统)，这种低延迟可能至关重要。  
对比：互斥锁的唤醒依赖操作系统调度，可能引入不确定的延迟。

#### <font color="dc843f">自旋锁的缺点与注意事项</font>
CPU 资源浪费：如果锁被长时间持有，自旋锁会导致线程空转，浪费 CPU 周期(尤其在单核系统中)。  
适用条件：仅适用于多核环境且锁持有时间极短的场景。若锁持有时间较长，应使用互斥锁或信号量。  
优先级反转风险：需结合优先级继承等机制避免(如 Linux 内核的 rtmutex)。

#### <font color="dc843f">自旋锁 vs 互斥锁(Mutex)</font>

| 特性               | 自旋锁(Spinlock)       | 互斥锁(Mutex)          |
| ------------------ | ------------------------ | ------------------------ |
| **等待方式**       | 忙等待(循环检查)       | 阻塞睡眠(让出 CPU)     |
| **上下文切换开销** | 无                       | 有(较高开销)           |
| **适用场景**       | 锁持有时间极短、多核环境 | 锁持有时间较长、单核环境 |
| **中断上下文**     | 可用                     | 不可用(可能触发调度)   |
| **CPU 利用率**     | 高(空转时占满 CPU)     | 低(睡眠时不占用 CPU)   |

## <font color="dc843f">How SpinLock</font>
参考  
[folly::SpinLock](https://github.com/facebook/folly/blob/main/folly/synchronization/MicroSpinLock.h)  
[atomic_queue::spinlock](https://github.com/max0x7ba/atomic_queue/blob/master/include/atomic_queue/spinlock.h)

其中关于spinLock实现中有个有趣的细节[pause](extension/pause.md)